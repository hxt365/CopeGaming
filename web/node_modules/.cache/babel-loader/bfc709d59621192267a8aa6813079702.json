{"ast":null,"code":"import { now, nextTick } from '../../shared/utils.js';\nexport default function onTouchEnd(event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    slidesGrid,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n\n  data.allowTouchCallbacks = false;\n\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  } // Return Grab Cursor\n\n\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  } // Time diff\n\n\n  const touchEndTime = now();\n  const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n  if (swiper.allowClick) {\n    const pathTree = e.path || e.composedPath && e.composedPath();\n    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n    swiper.emit('tap click', e);\n\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = now();\n  nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  let currentPos;\n\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (swiper.params.freeMode && params.freeMode.enabled) {\n    swiper.freeMode.onTouchEnd({\n      currentPos\n    });\n    return;\n  } // Find current slide\n\n\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n\n  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n    if (typeof slidesGrid[i + increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n\n  let rewindFirstIndex = null;\n  let rewindLastIndex = null;\n\n  if (params.rewind) {\n    if (swiper.isBeginning) {\n      rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    } else if (swiper.isEnd) {\n      rewindFirstIndex = 0;\n    }\n  } // Find current slide size\n\n\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) {\n        swiper.slideTo(stopIndex + increment);\n      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n        swiper.slideTo(rewindLastIndex);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n      }\n\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/hxt365/GolandProjects/cloud-gaming/web/node_modules/swiper/core/events/onTouchEnd.js"],"names":["now","nextTick","onTouchEnd","event","swiper","data","touchEventsData","params","touches","rtlTranslate","rtl","slidesGrid","enabled","e","originalEvent","allowTouchCallbacks","emit","isTouched","isMoved","grabCursor","setGrabCursor","startMoving","allowSlideNext","allowSlidePrev","touchEndTime","timeDiff","touchStartTime","allowClick","pathTree","path","composedPath","updateClickedSlide","target","lastClickTime","destroyed","swipeDirection","diff","currentTranslate","startTranslate","currentPos","followFinger","translate","cssMode","freeMode","stopIndex","groupSize","slidesSizesGrid","i","length","slidesPerGroupSkip","slidesPerGroup","increment","rewindFirstIndex","rewindLastIndex","rewind","isBeginning","virtual","slides","isEnd","ratio","longSwipesMs","longSwipes","slideTo","activeIndex","longSwipesRatio","Math","abs","shortSwipes","isNavButtonTarget","navigation","nextEl","prevEl"],"mappings":"AAAA,SAASA,GAAT,EAAcC,QAAd,QAA8B,uBAA9B;AACA,eAAe,SAASC,UAAT,CAAoBC,KAApB,EAA2B;AACxC,QAAMC,MAAM,GAAG,IAAf;AACA,QAAMC,IAAI,GAAGD,MAAM,CAACE,eAApB;AACA,QAAM;AACJC,IAAAA,MADI;AAEJC,IAAAA,OAFI;AAGJC,IAAAA,YAAY,EAAEC,GAHV;AAIJC,IAAAA,UAJI;AAKJC,IAAAA;AALI,MAMFR,MANJ;AAOA,MAAI,CAACQ,OAAL,EAAc;AACd,MAAIC,CAAC,GAAGV,KAAR;AACA,MAAIU,CAAC,CAACC,aAAN,EAAqBD,CAAC,GAAGA,CAAC,CAACC,aAAN;;AAErB,MAAIT,IAAI,CAACU,mBAAT,EAA8B;AAC5BX,IAAAA,MAAM,CAACY,IAAP,CAAY,UAAZ,EAAwBH,CAAxB;AACD;;AAEDR,EAAAA,IAAI,CAACU,mBAAL,GAA2B,KAA3B;;AAEA,MAAI,CAACV,IAAI,CAACY,SAAV,EAAqB;AACnB,QAAIZ,IAAI,CAACa,OAAL,IAAgBX,MAAM,CAACY,UAA3B,EAAuC;AACrCf,MAAAA,MAAM,CAACgB,aAAP,CAAqB,KAArB;AACD;;AAEDf,IAAAA,IAAI,CAACa,OAAL,GAAe,KAAf;AACAb,IAAAA,IAAI,CAACgB,WAAL,GAAmB,KAAnB;AACA;AACD,GA5BuC,CA4BtC;;;AAGF,MAAId,MAAM,CAACY,UAAP,IAAqBd,IAAI,CAACa,OAA1B,IAAqCb,IAAI,CAACY,SAA1C,KAAwDb,MAAM,CAACkB,cAAP,KAA0B,IAA1B,IAAkClB,MAAM,CAACmB,cAAP,KAA0B,IAApH,CAAJ,EAA+H;AAC7HnB,IAAAA,MAAM,CAACgB,aAAP,CAAqB,KAArB;AACD,GAjCuC,CAiCtC;;;AAGF,QAAMI,YAAY,GAAGxB,GAAG,EAAxB;AACA,QAAMyB,QAAQ,GAAGD,YAAY,GAAGnB,IAAI,CAACqB,cAArC,CArCwC,CAqCa;;AAErD,MAAItB,MAAM,CAACuB,UAAX,EAAuB;AACrB,UAAMC,QAAQ,GAAGf,CAAC,CAACgB,IAAF,IAAUhB,CAAC,CAACiB,YAAF,IAAkBjB,CAAC,CAACiB,YAAF,EAA7C;AACA1B,IAAAA,MAAM,CAAC2B,kBAAP,CAA0BH,QAAQ,IAAIA,QAAQ,CAAC,CAAD,CAApB,IAA2Bf,CAAC,CAACmB,MAAvD;AACA5B,IAAAA,MAAM,CAACY,IAAP,CAAY,WAAZ,EAAyBH,CAAzB;;AAEA,QAAIY,QAAQ,GAAG,GAAX,IAAkBD,YAAY,GAAGnB,IAAI,CAAC4B,aAApB,GAAoC,GAA1D,EAA+D;AAC7D7B,MAAAA,MAAM,CAACY,IAAP,CAAY,uBAAZ,EAAqCH,CAArC;AACD;AACF;;AAEDR,EAAAA,IAAI,CAAC4B,aAAL,GAAqBjC,GAAG,EAAxB;AACAC,EAAAA,QAAQ,CAAC,MAAM;AACb,QAAI,CAACG,MAAM,CAAC8B,SAAZ,EAAuB9B,MAAM,CAACuB,UAAP,GAAoB,IAApB;AACxB,GAFO,CAAR;;AAIA,MAAI,CAACtB,IAAI,CAACY,SAAN,IAAmB,CAACZ,IAAI,CAACa,OAAzB,IAAoC,CAACd,MAAM,CAAC+B,cAA5C,IAA8D3B,OAAO,CAAC4B,IAAR,KAAiB,CAA/E,IAAoF/B,IAAI,CAACgC,gBAAL,KAA0BhC,IAAI,CAACiC,cAAvH,EAAuI;AACrIjC,IAAAA,IAAI,CAACY,SAAL,GAAiB,KAAjB;AACAZ,IAAAA,IAAI,CAACa,OAAL,GAAe,KAAf;AACAb,IAAAA,IAAI,CAACgB,WAAL,GAAmB,KAAnB;AACA;AACD;;AAEDhB,EAAAA,IAAI,CAACY,SAAL,GAAiB,KAAjB;AACAZ,EAAAA,IAAI,CAACa,OAAL,GAAe,KAAf;AACAb,EAAAA,IAAI,CAACgB,WAAL,GAAmB,KAAnB;AACA,MAAIkB,UAAJ;;AAEA,MAAIhC,MAAM,CAACiC,YAAX,EAAyB;AACvBD,IAAAA,UAAU,GAAG7B,GAAG,GAAGN,MAAM,CAACqC,SAAV,GAAsB,CAACrC,MAAM,CAACqC,SAA9C;AACD,GAFD,MAEO;AACLF,IAAAA,UAAU,GAAG,CAAClC,IAAI,CAACgC,gBAAnB;AACD;;AAED,MAAI9B,MAAM,CAACmC,OAAX,EAAoB;AAClB;AACD;;AAED,MAAItC,MAAM,CAACG,MAAP,CAAcoC,QAAd,IAA0BpC,MAAM,CAACoC,QAAP,CAAgB/B,OAA9C,EAAuD;AACrDR,IAAAA,MAAM,CAACuC,QAAP,CAAgBzC,UAAhB,CAA2B;AACzBqC,MAAAA;AADyB,KAA3B;AAGA;AACD,GAjFuC,CAiFtC;;;AAGF,MAAIK,SAAS,GAAG,CAAhB;AACA,MAAIC,SAAS,GAAGzC,MAAM,CAAC0C,eAAP,CAAuB,CAAvB,CAAhB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpC,UAAU,CAACqC,MAA/B,EAAuCD,CAAC,IAAIA,CAAC,GAAGxC,MAAM,CAAC0C,kBAAX,GAAgC,CAAhC,GAAoC1C,MAAM,CAAC2C,cAAvF,EAAuG;AACrG,UAAMC,SAAS,GAAGJ,CAAC,GAAGxC,MAAM,CAAC0C,kBAAP,GAA4B,CAAhC,GAAoC,CAApC,GAAwC1C,MAAM,CAAC2C,cAAjE;;AAEA,QAAI,OAAOvC,UAAU,CAACoC,CAAC,GAAGI,SAAL,CAAjB,KAAqC,WAAzC,EAAsD;AACpD,UAAIZ,UAAU,IAAI5B,UAAU,CAACoC,CAAD,CAAxB,IAA+BR,UAAU,GAAG5B,UAAU,CAACoC,CAAC,GAAGI,SAAL,CAA1D,EAA2E;AACzEP,QAAAA,SAAS,GAAGG,CAAZ;AACAF,QAAAA,SAAS,GAAGlC,UAAU,CAACoC,CAAC,GAAGI,SAAL,CAAV,GAA4BxC,UAAU,CAACoC,CAAD,CAAlD;AACD;AACF,KALD,MAKO,IAAIR,UAAU,IAAI5B,UAAU,CAACoC,CAAD,CAA5B,EAAiC;AACtCH,MAAAA,SAAS,GAAGG,CAAZ;AACAF,MAAAA,SAAS,GAAGlC,UAAU,CAACA,UAAU,CAACqC,MAAX,GAAoB,CAArB,CAAV,GAAoCrC,UAAU,CAACA,UAAU,CAACqC,MAAX,GAAoB,CAArB,CAA1D;AACD;AACF;;AAED,MAAII,gBAAgB,GAAG,IAAvB;AACA,MAAIC,eAAe,GAAG,IAAtB;;AAEA,MAAI9C,MAAM,CAAC+C,MAAX,EAAmB;AACjB,QAAIlD,MAAM,CAACmD,WAAX,EAAwB;AACtBF,MAAAA,eAAe,GAAGjD,MAAM,CAACG,MAAP,CAAciD,OAAd,IAAyBpD,MAAM,CAACG,MAAP,CAAciD,OAAd,CAAsB5C,OAA/C,IAA0DR,MAAM,CAACoD,OAAjE,GAA2EpD,MAAM,CAACoD,OAAP,CAAeC,MAAf,CAAsBT,MAAtB,GAA+B,CAA1G,GAA8G5C,MAAM,CAACqD,MAAP,CAAcT,MAAd,GAAuB,CAAvJ;AACD,KAFD,MAEO,IAAI5C,MAAM,CAACsD,KAAX,EAAkB;AACvBN,MAAAA,gBAAgB,GAAG,CAAnB;AACD;AACF,GA9GuC,CA8GtC;;;AAGF,QAAMO,KAAK,GAAG,CAACpB,UAAU,GAAG5B,UAAU,CAACiC,SAAD,CAAxB,IAAuCC,SAArD;AACA,QAAMM,SAAS,GAAGP,SAAS,GAAGrC,MAAM,CAAC0C,kBAAP,GAA4B,CAAxC,GAA4C,CAA5C,GAAgD1C,MAAM,CAAC2C,cAAzE;;AAEA,MAAIzB,QAAQ,GAAGlB,MAAM,CAACqD,YAAtB,EAAoC;AAClC;AACA,QAAI,CAACrD,MAAM,CAACsD,UAAZ,EAAwB;AACtBzD,MAAAA,MAAM,CAAC0D,OAAP,CAAe1D,MAAM,CAAC2D,WAAtB;AACA;AACD;;AAED,QAAI3D,MAAM,CAAC+B,cAAP,KAA0B,MAA9B,EAAsC;AACpC,UAAIwB,KAAK,IAAIpD,MAAM,CAACyD,eAApB,EAAqC5D,MAAM,CAAC0D,OAAP,CAAevD,MAAM,CAAC+C,MAAP,IAAiBlD,MAAM,CAACsD,KAAxB,GAAgCN,gBAAhC,GAAmDR,SAAS,GAAGO,SAA9E,EAArC,KAAmI/C,MAAM,CAAC0D,OAAP,CAAelB,SAAf;AACpI;;AAED,QAAIxC,MAAM,CAAC+B,cAAP,KAA0B,MAA9B,EAAsC;AACpC,UAAIwB,KAAK,GAAG,IAAIpD,MAAM,CAACyD,eAAvB,EAAwC;AACtC5D,QAAAA,MAAM,CAAC0D,OAAP,CAAelB,SAAS,GAAGO,SAA3B;AACD,OAFD,MAEO,IAAIE,eAAe,KAAK,IAApB,IAA4BM,KAAK,GAAG,CAApC,IAAyCM,IAAI,CAACC,GAAL,CAASP,KAAT,IAAkBpD,MAAM,CAACyD,eAAtE,EAAuF;AAC5F5D,QAAAA,MAAM,CAAC0D,OAAP,CAAeT,eAAf;AACD,OAFM,MAEA;AACLjD,QAAAA,MAAM,CAAC0D,OAAP,CAAelB,SAAf;AACD;AACF;AACF,GApBD,MAoBO;AACL;AACA,QAAI,CAACrC,MAAM,CAAC4D,WAAZ,EAAyB;AACvB/D,MAAAA,MAAM,CAAC0D,OAAP,CAAe1D,MAAM,CAAC2D,WAAtB;AACA;AACD;;AAED,UAAMK,iBAAiB,GAAGhE,MAAM,CAACiE,UAAP,KAAsBxD,CAAC,CAACmB,MAAF,KAAa5B,MAAM,CAACiE,UAAP,CAAkBC,MAA/B,IAAyCzD,CAAC,CAACmB,MAAF,KAAa5B,MAAM,CAACiE,UAAP,CAAkBE,MAA9F,CAA1B;;AAEA,QAAI,CAACH,iBAAL,EAAwB;AACtB,UAAIhE,MAAM,CAAC+B,cAAP,KAA0B,MAA9B,EAAsC;AACpC/B,QAAAA,MAAM,CAAC0D,OAAP,CAAeV,gBAAgB,KAAK,IAArB,GAA4BA,gBAA5B,GAA+CR,SAAS,GAAGO,SAA1E;AACD;;AAED,UAAI/C,MAAM,CAAC+B,cAAP,KAA0B,MAA9B,EAAsC;AACpC/B,QAAAA,MAAM,CAAC0D,OAAP,CAAeT,eAAe,KAAK,IAApB,GAA2BA,eAA3B,GAA6CT,SAA5D;AACD;AACF,KARD,MAQO,IAAI/B,CAAC,CAACmB,MAAF,KAAa5B,MAAM,CAACiE,UAAP,CAAkBC,MAAnC,EAA2C;AAChDlE,MAAAA,MAAM,CAAC0D,OAAP,CAAelB,SAAS,GAAGO,SAA3B;AACD,KAFM,MAEA;AACL/C,MAAAA,MAAM,CAAC0D,OAAP,CAAelB,SAAf;AACD;AACF;AACF","sourcesContent":["import { now, nextTick } from '../../shared/utils.js';\nexport default function onTouchEnd(event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    slidesGrid,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n\n  data.allowTouchCallbacks = false;\n\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  } // Return Grab Cursor\n\n\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  } // Time diff\n\n\n  const touchEndTime = now();\n  const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n  if (swiper.allowClick) {\n    const pathTree = e.path || e.composedPath && e.composedPath();\n    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n    swiper.emit('tap click', e);\n\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = now();\n  nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  let currentPos;\n\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (swiper.params.freeMode && params.freeMode.enabled) {\n    swiper.freeMode.onTouchEnd({\n      currentPos\n    });\n    return;\n  } // Find current slide\n\n\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n\n  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n    if (typeof slidesGrid[i + increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n\n  let rewindFirstIndex = null;\n  let rewindLastIndex = null;\n\n  if (params.rewind) {\n    if (swiper.isBeginning) {\n      rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    } else if (swiper.isEnd) {\n      rewindFirstIndex = 0;\n    }\n  } // Find current slide size\n\n\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) {\n        swiper.slideTo(stopIndex + increment);\n      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n        swiper.slideTo(rewindLastIndex);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n      }\n\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}