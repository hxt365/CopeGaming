{"ast":null,"code":"import { setCSSProperty } from '../../shared/utils.js';\nexport default function updateSlides() {\n  const swiper = this;\n\n  function getDirectionLabel(property) {\n    if (swiper.isHorizontal()) {\n      return property;\n    } // prettier-ignore\n\n\n    return {\n      'width': 'height',\n      'margin-top': 'margin-left',\n      'margin-bottom ': 'margin-right',\n      'margin-left': 'margin-top',\n      'margin-right': 'margin-bottom',\n      'padding-left': 'padding-top',\n      'padding-right': 'padding-bottom',\n      'marginRight': 'marginBottom'\n    }[property];\n  }\n\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n  }\n\n  const params = swiper.params;\n  const {\n    $wrapperEl,\n    size: swiperSize,\n    rtlTranslate: rtl,\n    wrongRTL\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n  let offsetBefore = params.slidesOffsetBefore;\n\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n\n  let offsetAfter = params.slidesOffsetAfter;\n\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n  }\n\n  swiper.virtualSize = -spaceBetween; // reset margins\n\n  if (rtl) slides.css({\n    marginLeft: '',\n    marginBottom: '',\n    marginTop: ''\n  });else slides.css({\n    marginRight: '',\n    marginBottom: '',\n    marginTop: ''\n  }); // reset cssMode offsets\n\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');\n    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');\n  }\n\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n\n  if (gridEnabled) {\n    swiper.grid.initSlides(slidesLength);\n  } // Calc slides\n\n\n  let slideSize;\n  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n    return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n  }).length > 0;\n\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    const slide = slides.eq(i);\n\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n    }\n\n    if (slide.css('display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      if (shouldResetSlideSize) {\n        slides[i].style[getDirectionLabel('width')] = ``;\n      }\n\n      const slideStyles = getComputedStyle(slide[0]);\n      const currentTransform = slide[0].style.transform;\n      const currentWebKitTransform = slide[0].style.webkitTransform;\n\n      if (currentTransform) {\n        slide[0].style.transform = 'none';\n      }\n\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = 'none';\n      }\n\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);\n      } else {\n        // eslint-disable-next-line\n        const width = getDirectionPropertyValue(slideStyles, 'width');\n        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n        const boxSizing = slideStyles.getPropertyValue('box-sizing');\n\n        if (boxSizing && boxSizing === 'border-box') {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const {\n            clientWidth,\n            offsetWidth\n          } = slide[0];\n          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n        }\n      }\n\n      if (currentTransform) {\n        slide[0].style.transform = currentTransform;\n      }\n\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = currentWebKitTransform;\n      }\n\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n      if (slides[i]) {\n        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n      }\n    }\n\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n\n    slidesSizesGrid.push(slideSize);\n\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n\n    swiper.virtualSize += slideSize + spaceBetween;\n    prevSlideSize = slideSize;\n    index += 1;\n  }\n\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n\n  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    $wrapperEl.css({\n      width: `${swiper.virtualSize + params.spaceBetween}px`\n    });\n  }\n\n  if (params.setWrapperSize) {\n    $wrapperEl.css({\n      [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`\n    });\n  }\n\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n  } // Remove last grid elements depending on width\n\n\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n\n    snapGrid = newSlidesGrid;\n\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n\n  if (snapGrid.length === 0) snapGrid = [0];\n\n  if (params.spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n    slides.filter((_, slideIndex) => {\n      if (!params.cssMode) return true;\n\n      if (slideIndex === slides.length - 1) {\n        return false;\n      }\n\n      return true;\n    }).css({\n      [key]: `${spaceBetween}px`\n    });\n  }\n\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map(snap => {\n      if (snap < 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid\n  });\n\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n  }\n\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n\n  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);\n\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.$el.removeClass(backFaceHiddenClass);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/hxt365/GolandProjects/cloud-gaming/web/node_modules/swiper/core/update/updateSlides.js"],"names":["setCSSProperty","updateSlides","swiper","getDirectionLabel","property","isHorizontal","getDirectionPropertyValue","node","label","parseFloat","getPropertyValue","params","$wrapperEl","size","swiperSize","rtlTranslate","rtl","wrongRTL","isVirtual","virtual","enabled","previousSlidesLength","slides","length","children","slideClass","slidesLength","snapGrid","slidesGrid","slidesSizesGrid","offsetBefore","slidesOffsetBefore","call","offsetAfter","slidesOffsetAfter","previousSnapGridLength","previousSlidesGridLength","spaceBetween","slidePosition","prevSlideSize","index","indexOf","replace","virtualSize","css","marginLeft","marginBottom","marginTop","marginRight","centeredSlides","cssMode","wrapperEl","gridEnabled","grid","rows","initSlides","slideSize","shouldResetSlideSize","slidesPerView","breakpoints","Object","keys","filter","key","i","slide","eq","updateSlide","style","slideStyles","getComputedStyle","currentTransform","transform","currentWebKitTransform","webkitTransform","roundLengths","outerWidth","outerHeight","width","paddingLeft","paddingRight","boxSizing","clientWidth","offsetWidth","Math","floor","swiperSlideSize","push","abs","slidesPerGroup","min","slidesPerGroupSkip","max","effect","setWrapperSize","updateWrapperSize","newSlidesGrid","slidesGridItem","_","slideIndex","centeredSlidesBounds","allSlidesSize","forEach","slideSizeValue","maxSnap","map","snap","centerInsufficientSlides","allSlidesOffset","snapIndex","assign","addToSnapGrid","addToSlidesGrid","v","emit","watchOverflow","checkOverflow","watchSlidesProgress","updateSlidesOffset","backFaceHiddenClass","containerModifierClass","hasClassBackfaceClassAdded","$el","hasClass","maxBackfaceHiddenSlides","addClass","removeClass"],"mappings":"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","sourcesContent":["import { setCSSProperty } from '../../shared/utils.js';\nexport default function updateSlides() {\n  const swiper = this;\n\n  function getDirectionLabel(property) {\n    if (swiper.isHorizontal()) {\n      return property;\n    } // prettier-ignore\n\n\n    return {\n      'width': 'height',\n      'margin-top': 'margin-left',\n      'margin-bottom ': 'margin-right',\n      'margin-left': 'margin-top',\n      'margin-right': 'margin-bottom',\n      'padding-left': 'padding-top',\n      'padding-right': 'padding-bottom',\n      'marginRight': 'marginBottom'\n    }[property];\n  }\n\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n  }\n\n  const params = swiper.params;\n  const {\n    $wrapperEl,\n    size: swiperSize,\n    rtlTranslate: rtl,\n    wrongRTL\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n  let offsetBefore = params.slidesOffsetBefore;\n\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n\n  let offsetAfter = params.slidesOffsetAfter;\n\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n  }\n\n  swiper.virtualSize = -spaceBetween; // reset margins\n\n  if (rtl) slides.css({\n    marginLeft: '',\n    marginBottom: '',\n    marginTop: ''\n  });else slides.css({\n    marginRight: '',\n    marginBottom: '',\n    marginTop: ''\n  }); // reset cssMode offsets\n\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');\n    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');\n  }\n\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n\n  if (gridEnabled) {\n    swiper.grid.initSlides(slidesLength);\n  } // Calc slides\n\n\n  let slideSize;\n  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n    return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n  }).length > 0;\n\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    const slide = slides.eq(i);\n\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n    }\n\n    if (slide.css('display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      if (shouldResetSlideSize) {\n        slides[i].style[getDirectionLabel('width')] = ``;\n      }\n\n      const slideStyles = getComputedStyle(slide[0]);\n      const currentTransform = slide[0].style.transform;\n      const currentWebKitTransform = slide[0].style.webkitTransform;\n\n      if (currentTransform) {\n        slide[0].style.transform = 'none';\n      }\n\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = 'none';\n      }\n\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);\n      } else {\n        // eslint-disable-next-line\n        const width = getDirectionPropertyValue(slideStyles, 'width');\n        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n        const boxSizing = slideStyles.getPropertyValue('box-sizing');\n\n        if (boxSizing && boxSizing === 'border-box') {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const {\n            clientWidth,\n            offsetWidth\n          } = slide[0];\n          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n        }\n      }\n\n      if (currentTransform) {\n        slide[0].style.transform = currentTransform;\n      }\n\n      if (currentWebKitTransform) {\n        slide[0].style.webkitTransform = currentWebKitTransform;\n      }\n\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n      if (slides[i]) {\n        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n      }\n    }\n\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n\n    slidesSizesGrid.push(slideSize);\n\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n\n    swiper.virtualSize += slideSize + spaceBetween;\n    prevSlideSize = slideSize;\n    index += 1;\n  }\n\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n\n  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    $wrapperEl.css({\n      width: `${swiper.virtualSize + params.spaceBetween}px`\n    });\n  }\n\n  if (params.setWrapperSize) {\n    $wrapperEl.css({\n      [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`\n    });\n  }\n\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n  } // Remove last grid elements depending on width\n\n\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n\n    snapGrid = newSlidesGrid;\n\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n\n  if (snapGrid.length === 0) snapGrid = [0];\n\n  if (params.spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n    slides.filter((_, slideIndex) => {\n      if (!params.cssMode) return true;\n\n      if (slideIndex === slides.length - 1) {\n        return false;\n      }\n\n      return true;\n    }).css({\n      [key]: `${spaceBetween}px`\n    });\n  }\n\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map(snap => {\n      if (snap < 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n    });\n    allSlidesSize -= params.spaceBetween;\n\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid\n  });\n\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n  }\n\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n\n  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);\n\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.$el.removeClass(backFaceHiddenClass);\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}